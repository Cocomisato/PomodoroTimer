{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement == null ? void 0 : activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd,\n    value\n  } = element; // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n\n  if (!element.setSelectionRange || selectionStart === null) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    element.setSelectionRange(newSelectionStart, newSelectionEnd);\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/misato/Documents/Coding/Qualified/Project_Pomodoro_timer_Qualified_1/node_modules/@testing-library/user-event/dist/utils.js"],"names":["Object","defineProperty","exports","value","isFocusable","getMouseEventOptions","isLabelWithInternallyDisabledControl","getActiveElement","calculateNewValue","setSelectionRangeIfNecessary","eventWrapper","FOCUSABLE_SELECTOR","_dom","require","isMousePressEvent","event","invert","map","res","key","keys","BUTTONS_TO_NAMES","NAMES_TO_BUTTONS","BUTTON_TO_NAMES","NAMES_TO_BUTTON","convertMouseButtons","init","property","mapping","buttons","button","clickCount","detail","element","_element$control","tagName","control","disabled","contains","document","activeElement","shadowRoot","newEntry","_element$getAttribute","selectionStart","selectionEnd","maxLength","Number","getAttribute","newValue","newSelectionStart","length","slice","firstPart","newSelectionEnd","setSelectionRange","join","matches","cb","result","getConfig"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement == null ? void 0 : activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd,\n    value\n  } = element; // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n\n  if (!element.setSelectionRange || selectionStart === null) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    element.setSelectionRange(newSelectionStart, newSelectionEnd);\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}"]},"metadata":{},"sourceType":"script"}