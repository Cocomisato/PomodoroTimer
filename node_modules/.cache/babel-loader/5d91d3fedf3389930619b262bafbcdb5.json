{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\"); // TODO: wrap in asyncWrapper\n\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n  // This is why most of the utilities are within the type function itself. If\n  // they weren't, then we'd have to pass the \"currentElement\" function to them\n  // as an argument, which would be fine, but make sure that you pass the function\n  // and not just the element if the active element could change while the function\n  // is being run (for example, functions that are and/or fire events).\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument);\n\n  const currentValue = () => {\n    const activeElement = currentElement();\n    const value = activeElement.value;\n\n    if (typeof value === 'undefined') {\n      throw new TypeError(`the current element is of type ${activeElement.tagName} and doesn't have a valid value`);\n    }\n\n    return value;\n  };\n\n  const setSelectionRange = ({\n    newValue,\n    newSelectionStart\n  }) => {\n    // if we *can* change the selection start, then we will if the new value\n    // is the same as the current value (so it wasn't programatically changed\n    // when the fireEvent.input was triggered).\n    // The reason we have to do this at all is because it actually *is*\n    // programmatically changed by fireEvent.input, so we have to simulate the\n    // browser's default behavior\n    const value = currentValue();\n\n    if (value === newValue) {\n      (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n    } else {\n      // If the currentValue is different than the expected newValue and we *can*\n      // change the selection range, than we should set it to the length of the\n      // currentValue to ensure that the browser behavior is mimicked.\n      (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n    }\n  }; // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  if (currentElement().selectionStart === 0 && currentElement().selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : currentValue().length, initialSelectionEnd != null ? initialSelectionEnd : currentValue().length);\n  }\n\n  const eventCallbackMap = getEventCallbackMap({\n    currentElement,\n    currentValue,\n    fireInputEventIfNeeded,\n    setSelectionRange\n  });\n\n  const eventCallbacks = function () {\n    const callbacks = [];\n    const modifierClosers = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const eventKey = Object.keys(eventCallbackMap).find(key => remainingString.startsWith(key));\n\n      if (eventKey) {\n        const modifierCallback = eventCallbackMap[eventKey];\n        callbacks.push(modifierCallback); // if this modifier has an associated \"close\" callback and the developer\n        // doesn't close it themselves, then we close it for them automatically\n        // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n        if (!skipAutoClose && modifierCallback.close && !remainingString.includes(modifierCallback.close.name)) {\n          modifierClosers.push(modifierCallback.close.fn);\n        }\n\n        remainingString = remainingString.slice(eventKey.length);\n      } else {\n        const character = remainingString[0];\n        callbacks.push((...args) => typeCharacter(character, ...args));\n        remainingString = remainingString.slice(1);\n      }\n    }\n\n    return [...callbacks, ...modifierClosers];\n  }();\n\n  await async function (callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n      }\n    }\n  }(eventCallbacks);\n\n  function fireInputEventIfNeeded({\n    newValue,\n    newSelectionStart,\n    eventOverrides\n  }) {\n    const prevValue = currentValue();\n\n    if (!currentElement().readOnly && newValue !== prevValue) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n\n      setSelectionRange({\n        newValue,\n        newSelectionStart\n      });\n    }\n\n    return {\n      prevValue\n    };\n  }\n\n  function typeCharacter(char, {\n    prevWasMinus = false,\n    prevWasPeriod = false,\n    prevValue = '',\n    eventOverrides\n  }) {\n    const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n    const keyCode = char.charCodeAt(0);\n    let nextPrevWasMinus, nextPrevWasPeriod;\n\n    const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyDownDefaultNotPrevented) {\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n        key,\n        keyCode,\n        charCode: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        let newEntry = char;\n\n        if (prevWasMinus) {\n          newEntry = `-${char}`;\n        } else if (prevWasPeriod) {\n          newEntry = `${prevValue}.${char}`;\n        }\n\n        const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement(), currentValue()),\n          eventOverrides: {\n            data: key,\n            inputType: 'insertText',\n            ...eventOverrides\n          }\n        });\n        prevValue = inputEvent.prevValue; // typing \"-\" into a number input will not actually update the value\n        // so for the next character we type, the value should be set to\n        // `-${newEntry}`\n        // we also preserve the prevWasMinus when the value is unchanged due\n        // to typing an invalid character (typing \"-a3\" results in \"-3\")\n        // same applies for the decimal character.\n\n        if (currentElement().type === 'number') {\n          const newValue = currentValue();\n\n          if (newValue === prevValue && newEntry !== '-') {\n            nextPrevWasMinus = prevWasMinus;\n          } else {\n            nextPrevWasMinus = newEntry === '-';\n          }\n\n          if (newValue === prevValue && newEntry !== '.') {\n            nextPrevWasPeriod = prevWasPeriod;\n          } else {\n            nextPrevWasPeriod = newEntry === '.';\n          }\n        }\n      }\n    }\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides\n    });\n\n    return {\n      prevWasMinus: nextPrevWasMinus,\n      prevWasPeriod: nextPrevWasPeriod,\n      prevValue\n    };\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element, value) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element, value) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction getEventCallbackMap({\n  currentElement,\n  currentValue,\n  fireInputEventIfNeeded,\n  setSelectionRange\n}) {\n  return { ...modifier({\n      name: 'shift',\n      key: 'Shift',\n      keyCode: 16,\n      modifierProperty: 'shiftKey'\n    }),\n    ...modifier({\n      name: 'ctrl',\n      key: 'Control',\n      keyCode: 17,\n      modifierProperty: 'ctrlKey'\n    }),\n    ...modifier({\n      name: 'alt',\n      key: 'Alt',\n      keyCode: 18,\n      modifierProperty: 'altKey'\n    }),\n    ...modifier({\n      name: 'meta',\n      key: 'Meta',\n      keyCode: 93,\n      modifierProperty: 'metaKey'\n    }),\n    '{enter}': ({\n      eventOverrides\n    }) => {\n      const key = 'Enter';\n      const keyCode = 13;\n\n      const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyDownDefaultNotPrevented) {\n        _dom.fireEvent.keyPress(currentElement(), {\n          key,\n          keyCode,\n          charCode: keyCode,\n          ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'BUTTON') {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement(), currentValue());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{esc}': ({\n      eventOverrides\n    }) => {\n      const key = 'Escape';\n      const keyCode = 27;\n\n      _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{del}': ({\n      eventOverrides\n    }) => {\n      const key = 'Delete';\n      const keyCode = 46;\n\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement(), currentValue()),\n          eventOverrides: {\n            inputType: 'deleteContentForward',\n            ...eventOverrides\n          }\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{backspace}': ({\n      eventOverrides\n    }) => {\n      const key = 'Backspace';\n      const keyCode = 8;\n\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement(), currentValue()),\n          eventOverrides: {\n            inputType: 'deleteContentBackward',\n            ...eventOverrides\n          }\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    // the user can actually select in several different ways\n    // we're not going to choose, so we'll *only* set the selection range\n    '{selectall}': () => {\n      currentElement().setSelectionRange(0, currentValue().length);\n    }\n  };\n\n  function modifier({\n    name,\n    key,\n    keyCode,\n    modifierProperty\n  }) {\n    function open({\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: true\n      };\n\n      _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n\n    open.close = {\n      name: [`{/${name}}`],\n      fn: close\n    };\n\n    function close({\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: false\n      };\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n\n    return {\n      [`{${name}}`]: open,\n      [`{/${name}}`]: close\n    };\n  }\n}\n/*\neslint\n  no-loop-func: \"off\",\n  max-lines-per-function: \"off\",\n*/","map":{"version":3,"sources":["/Users/misato/Documents/Coding/Qualified/Project_Pomodoro_timer_Qualified_1/node_modules/@testing-library/user-event/dist/type.js"],"names":["Object","defineProperty","exports","value","type","_dom","require","_utils","_click","wait","time","Promise","resolve","setTimeout","element","text","delay","options","result","getConfig","asyncWrapper","typeImpl","skipClick","skipAutoClose","initialSelectionStart","initialSelectionEnd","disabled","click","currentElement","getActiveElement","ownerDocument","currentValue","activeElement","TypeError","tagName","setSelectionRange","newValue","newSelectionStart","setSelectionRangeIfNecessary","length","selectionStart","selectionEnd","eventCallbackMap","getEventCallbackMap","fireInputEventIfNeeded","eventCallbacks","callbacks","modifierClosers","remainingString","eventKey","keys","find","key","startsWith","modifierCallback","push","close","includes","name","fn","slice","character","args","typeCharacter","eventOverrides","prevWasMinus","prevWasPeriod","prevValue","callback","returnValue","assign","readOnly","fireEvent","input","target","char","keyCode","charCodeAt","nextPrevWasMinus","nextPrevWasPeriod","keyDownDefaultNotPrevented","keyDown","which","keyPressDefaultNotPrevented","keyPress","charCode","newEntry","inputEvent","calculateNewValue","data","inputType","keyUp","calculateNewBackspaceValue","firstPart","calculateNewDeleteValue","modifier","modifierProperty","open","newEventOverrides"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,IAAR,GAAeA,IAAf;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,sBAAD,CAAlB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIE,MAAM,GAAGF,OAAO,CAAC,SAAD,CAApB,C,CAEA;;;AACA,SAASG,IAAT,CAAcC,IAAd,EAAoB;AAClB,SAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAIC,UAAU,CAAC,MAAMD,OAAO,EAAd,EAAkBF,IAAlB,CAAjC,CAAP;AACD,C,CAAC;AACF;;;AAGA,eAAeN,IAAf,CAAoBU,OAApB,EAA6BC,IAA7B,EAAmC;AACjCC,EAAAA,KAAK,GAAG,CADyB;AAEjC,KAAGC;AAF8B,IAG/B,EAHJ,EAGQ;AACN;AACA;AACA;AACA,MAAIC,MAAJ;;AAEA,MAAIF,KAAK,GAAG,CAAZ,EAAe;AACb,UAAM,CAAC,GAAGX,IAAI,CAACc,SAAT,IAAsBC,YAAtB,CAAmC,YAAY;AACnDF,MAAAA,MAAM,GAAG,MAAMG,QAAQ,CAACP,OAAD,EAAUC,IAAV,EAAgB;AACrCC,QAAAA,KADqC;AAErC,WAAGC;AAFkC,OAAhB,CAAvB;AAID,KALK,CAAN;AAMD,GAPD,MAOO;AACLC,IAAAA,MAAM,GAAGG,QAAQ,CAACP,OAAD,EAAUC,IAAV,EAAgB;AAC/BC,MAAAA,KAD+B;AAE/B,SAAGC;AAF4B,KAAhB,CAAjB;AAID;;AAED,SAAOC,MAAP;AACD;;AAED,eAAeG,QAAf,CAAwBP,OAAxB,EAAiCC,IAAjC,EAAuC;AACrCC,EAAAA,KADqC;AAErCM,EAAAA,SAAS,GAAG,KAFyB;AAGrCC,EAAAA,aAAa,GAAG,KAHqB;AAIrCC,EAAAA,qBAJqC;AAKrCC,EAAAA;AALqC,CAAvC,EAMG;AACD,MAAIX,OAAO,CAACY,QAAZ,EAAsB;AACtB,MAAI,CAACJ,SAAL,EAAgB,CAAC,GAAGd,MAAM,CAACmB,KAAX,EAAkBb,OAAlB,EAFf,CAE2C;AAC5C;AACA;AACA;AACA;AACA;;AAEA,QAAMc,cAAc,GAAG,MAAM,CAAC,GAAGrB,MAAM,CAACsB,gBAAX,EAA6Bf,OAAO,CAACgB,aAArC,CAA7B;;AAEA,QAAMC,YAAY,GAAG,MAAM;AACzB,UAAMC,aAAa,GAAGJ,cAAc,EAApC;AACA,UAAMzB,KAAK,GAAG6B,aAAa,CAAC7B,KAA5B;;AAEA,QAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC;AAChC,YAAM,IAAI8B,SAAJ,CAAe,kCAAiCD,aAAa,CAACE,OAAQ,iCAAtE,CAAN;AACD;;AAED,WAAO/B,KAAP;AACD,GATD;;AAWA,QAAMgC,iBAAiB,GAAG,CAAC;AACzBC,IAAAA,QADyB;AAEzBC,IAAAA;AAFyB,GAAD,KAGpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,UAAMlC,KAAK,GAAG4B,YAAY,EAA1B;;AAEA,QAAI5B,KAAK,KAAKiC,QAAd,EAAwB;AACtB,OAAC,GAAG7B,MAAM,CAAC+B,4BAAX,EAAyCV,cAAc,EAAvD,EAA2DS,iBAA3D,EAA8EA,iBAA9E;AACD,KAFD,MAEO;AACL;AACA;AACA;AACA,OAAC,GAAG9B,MAAM,CAAC+B,4BAAX,EAAyCV,cAAc,EAAvD,EAA2DzB,KAAK,CAACoC,MAAjE,EAAyEpC,KAAK,CAACoC,MAA/E;AACD;AACF,GApBD,CAtBC,CA0CE;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAIX,cAAc,GAAGY,cAAjB,KAAoC,CAApC,IAAyCZ,cAAc,GAAGa,YAAjB,KAAkC,CAA/E,EAAkF;AAChF,KAAC,GAAGlC,MAAM,CAAC+B,4BAAX,EAAyCV,cAAc,EAAvD,EAA2DJ,qBAAqB,IAAI,IAAzB,GAAgCA,qBAAhC,GAAwDO,YAAY,GAAGQ,MAAlI,EAA0Id,mBAAmB,IAAI,IAAvB,GAA8BA,mBAA9B,GAAoDM,YAAY,GAAGQ,MAA7M;AACD;;AAED,QAAMG,gBAAgB,GAAGC,mBAAmB,CAAC;AAC3Cf,IAAAA,cAD2C;AAE3CG,IAAAA,YAF2C;AAG3Ca,IAAAA,sBAH2C;AAI3CT,IAAAA;AAJ2C,GAAD,CAA5C;;AAOA,QAAMU,cAAc,GAAG,YAAY;AACjC,UAAMC,SAAS,GAAG,EAAlB;AACA,UAAMC,eAAe,GAAG,EAAxB;AACA,QAAIC,eAAe,GAAGjC,IAAtB;;AAEA,WAAOiC,eAAP,EAAwB;AACtB,YAAMC,QAAQ,GAAGjD,MAAM,CAACkD,IAAP,CAAYR,gBAAZ,EAA8BS,IAA9B,CAAmCC,GAAG,IAAIJ,eAAe,CAACK,UAAhB,CAA2BD,GAA3B,CAA1C,CAAjB;;AAEA,UAAIH,QAAJ,EAAc;AACZ,cAAMK,gBAAgB,GAAGZ,gBAAgB,CAACO,QAAD,CAAzC;AACAH,QAAAA,SAAS,CAACS,IAAV,CAAeD,gBAAf,EAFY,CAEsB;AAClC;AACA;;AAEA,YAAI,CAAC/B,aAAD,IAAkB+B,gBAAgB,CAACE,KAAnC,IAA4C,CAACR,eAAe,CAACS,QAAhB,CAAyBH,gBAAgB,CAACE,KAAjB,CAAuBE,IAAhD,CAAjD,EAAwG;AACtGX,UAAAA,eAAe,CAACQ,IAAhB,CAAqBD,gBAAgB,CAACE,KAAjB,CAAuBG,EAA5C;AACD;;AAEDX,QAAAA,eAAe,GAAGA,eAAe,CAACY,KAAhB,CAAsBX,QAAQ,CAACV,MAA/B,CAAlB;AACD,OAXD,MAWO;AACL,cAAMsB,SAAS,GAAGb,eAAe,CAAC,CAAD,CAAjC;AACAF,QAAAA,SAAS,CAACS,IAAV,CAAe,CAAC,GAAGO,IAAJ,KAAaC,aAAa,CAACF,SAAD,EAAY,GAAGC,IAAf,CAAzC;AACAd,QAAAA,eAAe,GAAGA,eAAe,CAACY,KAAhB,CAAsB,CAAtB,CAAlB;AACD;AACF;;AAED,WAAO,CAAC,GAAGd,SAAJ,EAAe,GAAGC,eAAlB,CAAP;AACD,GA3BsB,EAAvB;;AA6BA,QAAM,gBAAgBD,SAAhB,EAA2B;AAC/B,UAAMkB,cAAc,GAAG,EAAvB;AACA,QAAIC,YAAJ,EAAkBC,aAAlB,EAAiCC,SAAjC;;AAEA,SAAK,MAAMC,QAAX,IAAuBtB,SAAvB,EAAkC;AAChC,UAAI9B,KAAK,GAAG,CAAZ,EAAe,MAAMP,IAAI,CAACO,KAAD,CAAV;;AAEf,UAAI,CAACY,cAAc,GAAGF,QAAtB,EAAgC;AAC9B,cAAM2C,WAAW,GAAGD,QAAQ,CAAC;AAC3BH,UAAAA,YAD2B;AAE3BC,UAAAA,aAF2B;AAG3BC,UAAAA,SAH2B;AAI3BH,UAAAA;AAJ2B,SAAD,CAA5B;AAMAhE,QAAAA,MAAM,CAACsE,MAAP,CAAcN,cAAd,EAA8BK,WAAW,IAAI,IAAf,GAAsB,KAAK,CAA3B,GAA+BA,WAAW,CAACL,cAAzE;AACAC,QAAAA,YAAY,GAAGI,WAAW,IAAI,IAAf,GAAsB,KAAK,CAA3B,GAA+BA,WAAW,CAACJ,YAA1D;AACAC,QAAAA,aAAa,GAAGG,WAAW,IAAI,IAAf,GAAsB,KAAK,CAA3B,GAA+BA,WAAW,CAACH,aAA3D;AACAC,QAAAA,SAAS,GAAGE,WAAW,IAAI,IAAf,GAAsB,KAAK,CAA3B,GAA+BA,WAAW,CAACF,SAAvD;AACD;AACF;AACF,GApBK,CAoBJtB,cApBI,CAAN;;AAsBA,WAASD,sBAAT,CAAgC;AAC9BR,IAAAA,QAD8B;AAE9BC,IAAAA,iBAF8B;AAG9B2B,IAAAA;AAH8B,GAAhC,EAIG;AACD,UAAMG,SAAS,GAAGpC,YAAY,EAA9B;;AAEA,QAAI,CAACH,cAAc,GAAG2C,QAAlB,IAA8BnC,QAAQ,KAAK+B,SAA/C,EAA0D;AACxD9D,MAAAA,IAAI,CAACmE,SAAL,CAAeC,KAAf,CAAqB7C,cAAc,EAAnC,EAAuC;AACrC8C,QAAAA,MAAM,EAAE;AACNvE,UAAAA,KAAK,EAAEiC;AADD,SAD6B;AAIrC,WAAG4B;AAJkC,OAAvC;;AAOA7B,MAAAA,iBAAiB,CAAC;AAChBC,QAAAA,QADgB;AAEhBC,QAAAA;AAFgB,OAAD,CAAjB;AAID;;AAED,WAAO;AACL8B,MAAAA;AADK,KAAP;AAGD;;AAED,WAASJ,aAAT,CAAuBY,IAAvB,EAA6B;AAC3BV,IAAAA,YAAY,GAAG,KADY;AAE3BC,IAAAA,aAAa,GAAG,KAFW;AAG3BC,IAAAA,SAAS,GAAG,EAHe;AAI3BH,IAAAA;AAJ2B,GAA7B,EAKG;AACD,UAAMZ,GAAG,GAAGuB,IAAZ,CADC,CACiB;;AAElB,UAAMC,OAAO,GAAGD,IAAI,CAACE,UAAL,CAAgB,CAAhB,CAAhB;AACA,QAAIC,gBAAJ,EAAsBC,iBAAtB;;AAEA,UAAMC,0BAA0B,GAAG3E,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AAC1EwB,MAAAA,GAD0E;AAE1EwB,MAAAA,OAF0E;AAG1EM,MAAAA,KAAK,EAAEN,OAHmE;AAI1E,SAAGZ;AAJuE,KAAzC,CAAnC;;AAOA,QAAIgB,0BAAJ,EAAgC;AAC9B,YAAMG,2BAA2B,GAAG9E,IAAI,CAACmE,SAAL,CAAeY,QAAf,CAAwBxD,cAAc,EAAtC,EAA0C;AAC5EwB,QAAAA,GAD4E;AAE5EwB,QAAAA,OAF4E;AAG5ES,QAAAA,QAAQ,EAAET,OAHkE;AAI5E,WAAGZ;AAJyE,OAA1C,CAApC;;AAOA,UAAImB,2BAAJ,EAAiC;AAC/B,YAAIG,QAAQ,GAAGX,IAAf;;AAEA,YAAIV,YAAJ,EAAkB;AAChBqB,UAAAA,QAAQ,GAAI,IAAGX,IAAK,EAApB;AACD,SAFD,MAEO,IAAIT,aAAJ,EAAmB;AACxBoB,UAAAA,QAAQ,GAAI,GAAEnB,SAAU,IAAGQ,IAAK,EAAhC;AACD;;AAED,cAAMY,UAAU,GAAG3C,sBAAsB,CAAC,EAAE,GAAG,CAAC,GAAGrC,MAAM,CAACiF,iBAAX,EAA8BF,QAA9B,EAAwC1D,cAAc,EAAtD,EAA0DG,YAAY,EAAtE,CAAL;AACxCiC,UAAAA,cAAc,EAAE;AACdyB,YAAAA,IAAI,EAAErC,GADQ;AAEdsC,YAAAA,SAAS,EAAE,YAFG;AAGd,eAAG1B;AAHW;AADwB,SAAD,CAAzC;AAOAG,QAAAA,SAAS,GAAGoB,UAAU,CAACpB,SAAvB,CAhB+B,CAgBG;AAClC;AACA;AACA;AACA;AACA;;AAEA,YAAIvC,cAAc,GAAGxB,IAAjB,KAA0B,QAA9B,EAAwC;AACtC,gBAAMgC,QAAQ,GAAGL,YAAY,EAA7B;;AAEA,cAAIK,QAAQ,KAAK+B,SAAb,IAA0BmB,QAAQ,KAAK,GAA3C,EAAgD;AAC9CR,YAAAA,gBAAgB,GAAGb,YAAnB;AACD,WAFD,MAEO;AACLa,YAAAA,gBAAgB,GAAGQ,QAAQ,KAAK,GAAhC;AACD;;AAED,cAAIlD,QAAQ,KAAK+B,SAAb,IAA0BmB,QAAQ,KAAK,GAA3C,EAAgD;AAC9CP,YAAAA,iBAAiB,GAAGb,aAApB;AACD,WAFD,MAEO;AACLa,YAAAA,iBAAiB,GAAGO,QAAQ,KAAK,GAAjC;AACD;AACF;AACF;AACF;;AAEDjF,IAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,MAAAA,GADqC;AAErCwB,MAAAA,OAFqC;AAGrCM,MAAAA,KAAK,EAAEN,OAH8B;AAIrC,SAAGZ;AAJkC,KAAvC;;AAOA,WAAO;AACLC,MAAAA,YAAY,EAAEa,gBADT;AAELZ,MAAAA,aAAa,EAAEa,iBAFV;AAGLZ,MAAAA;AAHK,KAAP;AAKD;AACF,C,CAAC;AACF;AACA;AACA;;;AAGA,SAASyB,0BAAT,CAAoC9E,OAApC,EAA6CX,KAA7C,EAAoD;AAClD,QAAM;AACJqC,IAAAA,cADI;AAEJC,IAAAA;AAFI,MAGF3B,OAHJ;AAIA,MAAIsB,QAAJ,EAAcC,iBAAd;;AAEA,MAAIG,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA;AACAJ,IAAAA,QAAQ,GAAGjC,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAezD,KAAK,CAACoC,MAAN,GAAe,CAA9B,CAAX;AACAF,IAAAA,iBAAiB,GAAGG,cAAc,GAAG,CAArC;AACD,GALD,MAKO,IAAIA,cAAc,KAAKC,YAAvB,EAAqC;AAC1C,QAAID,cAAc,KAAK,CAAvB,EAA0B;AACxB;AACAJ,MAAAA,QAAQ,GAAGjC,KAAX;AACAkC,MAAAA,iBAAiB,GAAGG,cAApB;AACD,KAJD,MAIO,IAAIA,cAAc,KAAKrC,KAAK,CAACoC,MAA7B,EAAqC;AAC1C;AACAH,MAAAA,QAAQ,GAAGjC,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAezD,KAAK,CAACoC,MAAN,GAAe,CAA9B,CAAX;AACAF,MAAAA,iBAAiB,GAAGG,cAAc,GAAG,CAArC;AACD,KAJM,MAIA;AACL;AACAJ,MAAAA,QAAQ,GAAGjC,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAepB,cAAc,GAAG,CAAhC,IAAqCrC,KAAK,CAACyD,KAAN,CAAYnB,YAAZ,CAAhD;AACAJ,MAAAA,iBAAiB,GAAGG,cAAc,GAAG,CAArC;AACD;AACF,GAdM,MAcA;AACL;AACA,UAAMqD,SAAS,GAAG1F,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAepB,cAAf,CAAlB;AACAJ,IAAAA,QAAQ,GAAGyD,SAAS,GAAG1F,KAAK,CAACyD,KAAN,CAAYnB,YAAZ,CAAvB;AACAJ,IAAAA,iBAAiB,GAAGwD,SAAS,CAACtD,MAA9B;AACD;;AAED,SAAO;AACLH,IAAAA,QADK;AAELC,IAAAA;AAFK,GAAP;AAID;;AAED,SAASyD,uBAAT,CAAiChF,OAAjC,EAA0CX,KAA1C,EAAiD;AAC/C,QAAM;AACJqC,IAAAA,cADI;AAEJC,IAAAA;AAFI,MAGF3B,OAHJ;AAIA,MAAIsB,QAAJ;;AAEA,MAAII,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA;AACAJ,IAAAA,QAAQ,GAAGjC,KAAX;AACD,GAJD,MAIO,IAAIqC,cAAc,KAAKC,YAAvB,EAAqC;AAC1C,QAAID,cAAc,KAAK,CAAvB,EAA0B;AACxB;AACAJ,MAAAA,QAAQ,GAAGjC,KAAK,CAACyD,KAAN,CAAY,CAAZ,CAAX;AACD,KAHD,MAGO,IAAIpB,cAAc,KAAKrC,KAAK,CAACoC,MAA7B,EAAqC;AAC1C;AACAH,MAAAA,QAAQ,GAAGjC,KAAX;AACD,KAHM,MAGA;AACL;AACAiC,MAAAA,QAAQ,GAAGjC,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAepB,cAAf,IAAiCrC,KAAK,CAACyD,KAAN,CAAYnB,YAAY,GAAG,CAA3B,CAA5C;AACD;AACF,GAXM,MAWA;AACL;AACA,UAAMoD,SAAS,GAAG1F,KAAK,CAACyD,KAAN,CAAY,CAAZ,EAAepB,cAAf,CAAlB;AACAJ,IAAAA,QAAQ,GAAGyD,SAAS,GAAG1F,KAAK,CAACyD,KAAN,CAAYnB,YAAZ,CAAvB;AACD;;AAED,SAAO;AACLL,IAAAA,QADK;AAELC,IAAAA,iBAAiB,EAAEG;AAFd,GAAP;AAID;;AAED,SAASG,mBAAT,CAA6B;AAC3Bf,EAAAA,cAD2B;AAE3BG,EAAAA,YAF2B;AAG3Ba,EAAAA,sBAH2B;AAI3BT,EAAAA;AAJ2B,CAA7B,EAKG;AACD,SAAO,EAAE,GAAG4D,QAAQ,CAAC;AACjBrC,MAAAA,IAAI,EAAE,OADW;AAEjBN,MAAAA,GAAG,EAAE,OAFY;AAGjBwB,MAAAA,OAAO,EAAE,EAHQ;AAIjBoB,MAAAA,gBAAgB,EAAE;AAJD,KAAD,CAAb;AAML,OAAGD,QAAQ,CAAC;AACVrC,MAAAA,IAAI,EAAE,MADI;AAEVN,MAAAA,GAAG,EAAE,SAFK;AAGVwB,MAAAA,OAAO,EAAE,EAHC;AAIVoB,MAAAA,gBAAgB,EAAE;AAJR,KAAD,CANN;AAYL,OAAGD,QAAQ,CAAC;AACVrC,MAAAA,IAAI,EAAE,KADI;AAEVN,MAAAA,GAAG,EAAE,KAFK;AAGVwB,MAAAA,OAAO,EAAE,EAHC;AAIVoB,MAAAA,gBAAgB,EAAE;AAJR,KAAD,CAZN;AAkBL,OAAGD,QAAQ,CAAC;AACVrC,MAAAA,IAAI,EAAE,MADI;AAEVN,MAAAA,GAAG,EAAE,MAFK;AAGVwB,MAAAA,OAAO,EAAE,EAHC;AAIVoB,MAAAA,gBAAgB,EAAE;AAJR,KAAD,CAlBN;AAwBL,eAAW,CAAC;AACVhC,MAAAA;AADU,KAAD,KAEL;AACJ,YAAMZ,GAAG,GAAG,OAAZ;AACA,YAAMwB,OAAO,GAAG,EAAhB;;AAEA,YAAMI,0BAA0B,GAAG3E,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AAC1EwB,QAAAA,GAD0E;AAE1EwB,QAAAA,OAF0E;AAG1EM,QAAAA,KAAK,EAAEN,OAHmE;AAI1E,WAAGZ;AAJuE,OAAzC,CAAnC;;AAOA,UAAIgB,0BAAJ,EAAgC;AAC9B3E,QAAAA,IAAI,CAACmE,SAAL,CAAeY,QAAf,CAAwBxD,cAAc,EAAtC,EAA0C;AACxCwB,UAAAA,GADwC;AAExCwB,UAAAA,OAFwC;AAGxCS,UAAAA,QAAQ,EAAET,OAH8B;AAIxC,aAAGZ;AAJqC,SAA1C;AAMD;;AAED,UAAIpC,cAAc,GAAGM,OAAjB,KAA6B,QAAjC,EAA2C;AACzC7B,QAAAA,IAAI,CAACmE,SAAL,CAAe7C,KAAf,CAAqBC,cAAc,EAAnC,EAAuC,EAAE,GAAGoC;AAAL,SAAvC;AAED;;AAED,UAAIpC,cAAc,GAAGM,OAAjB,KAA6B,UAAjC,EAA6C;AAC3C,cAAM;AACJE,UAAAA,QADI;AAEJC,UAAAA;AAFI,YAGF,CAAC,GAAG9B,MAAM,CAACiF,iBAAX,EAA8B,IAA9B,EAAoC5D,cAAc,EAAlD,EAAsDG,YAAY,EAAlE,CAHJ;;AAKA1B,QAAAA,IAAI,CAACmE,SAAL,CAAeC,KAAf,CAAqB7C,cAAc,EAAnC,EAAuC;AACrC8C,UAAAA,MAAM,EAAE;AACNvE,YAAAA,KAAK,EAAEiC;AADD,WAD6B;AAIrCsD,UAAAA,SAAS,EAAE,iBAJ0B;AAKrC,aAAG1B;AALkC,SAAvC;;AAQA7B,QAAAA,iBAAiB,CAAC;AAChBC,UAAAA,QADgB;AAEhBC,UAAAA;AAFgB,SAAD,CAAjB;AAID;;AAEDhC,MAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,QAAAA,GADqC;AAErCwB,QAAAA,OAFqC;AAGrCM,QAAAA,KAAK,EAAEN,OAH8B;AAIrC,WAAGZ;AAJkC,OAAvC;AAMD,KA7EI;AA8EL,aAAS,CAAC;AACRA,MAAAA;AADQ,KAAD,KAEH;AACJ,YAAMZ,GAAG,GAAG,QAAZ;AACA,YAAMwB,OAAO,GAAG,EAAhB;;AAEAvE,MAAAA,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AACvCwB,QAAAA,GADuC;AAEvCwB,QAAAA,OAFuC;AAGvCM,QAAAA,KAAK,EAAEN,OAHgC;AAIvC,WAAGZ;AAJoC,OAAzC,EAJI,CASA;;;AAGJ3D,MAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,QAAAA,GADqC;AAErCwB,QAAAA,OAFqC;AAGrCM,QAAAA,KAAK,EAAEN,OAH8B;AAIrC,WAAGZ;AAJkC,OAAvC;AAMD,KAlGI;AAmGL,aAAS,CAAC;AACRA,MAAAA;AADQ,KAAD,KAEH;AACJ,YAAMZ,GAAG,GAAG,QAAZ;AACA,YAAMwB,OAAO,GAAG,EAAhB;;AAEA,YAAMO,2BAA2B,GAAG9E,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AAC3EwB,QAAAA,GAD2E;AAE3EwB,QAAAA,OAF2E;AAG3EM,QAAAA,KAAK,EAAEN,OAHoE;AAI3E,WAAGZ;AAJwE,OAAzC,CAApC;;AAOA,UAAImB,2BAAJ,EAAiC;AAC/BvC,QAAAA,sBAAsB,CAAC,EAAE,GAAGkD,uBAAuB,CAAClE,cAAc,EAAf,EAAmBG,YAAY,EAA/B,CAA5B;AACrBiC,UAAAA,cAAc,EAAE;AACd0B,YAAAA,SAAS,EAAE,sBADG;AAEd,eAAG1B;AAFW;AADK,SAAD,CAAtB;AAMD;;AAED3D,MAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,QAAAA,GADqC;AAErCwB,QAAAA,OAFqC;AAGrCM,QAAAA,KAAK,EAAEN,OAH8B;AAIrC,WAAGZ;AAJkC,OAAvC;AAMD,KA/HI;AAgIL,mBAAe,CAAC;AACdA,MAAAA;AADc,KAAD,KAET;AACJ,YAAMZ,GAAG,GAAG,WAAZ;AACA,YAAMwB,OAAO,GAAG,CAAhB;;AAEA,YAAMO,2BAA2B,GAAG9E,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AAC3EwB,QAAAA,GAD2E;AAE3EwB,QAAAA,OAF2E;AAG3EM,QAAAA,KAAK,EAAEN,OAHoE;AAI3E,WAAGZ;AAJwE,OAAzC,CAApC;;AAOA,UAAImB,2BAAJ,EAAiC;AAC/BvC,QAAAA,sBAAsB,CAAC,EAAE,GAAGgD,0BAA0B,CAAChE,cAAc,EAAf,EAAmBG,YAAY,EAA/B,CAA/B;AACrBiC,UAAAA,cAAc,EAAE;AACd0B,YAAAA,SAAS,EAAE,uBADG;AAEd,eAAG1B;AAFW;AADK,SAAD,CAAtB;AAMD;;AAED3D,MAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,QAAAA,GADqC;AAErCwB,QAAAA,OAFqC;AAGrCM,QAAAA,KAAK,EAAEN,OAH8B;AAIrC,WAAGZ;AAJkC,OAAvC;AAMD,KA5JI;AA6JL;AACA;AACA,mBAAe,MAAM;AACnBpC,MAAAA,cAAc,GAAGO,iBAAjB,CAAmC,CAAnC,EAAsCJ,YAAY,GAAGQ,MAArD;AACD;AAjKI,GAAP;;AAoKA,WAASwD,QAAT,CAAkB;AAChBrC,IAAAA,IADgB;AAEhBN,IAAAA,GAFgB;AAGhBwB,IAAAA,OAHgB;AAIhBoB,IAAAA;AAJgB,GAAlB,EAKG;AACD,aAASC,IAAT,CAAc;AACZjC,MAAAA;AADY,KAAd,EAEG;AACD,YAAMkC,iBAAiB,GAAG;AACxB,SAACF,gBAAD,GAAoB;AADI,OAA1B;;AAIA3F,MAAAA,IAAI,CAACmE,SAAL,CAAeS,OAAf,CAAuBrD,cAAc,EAArC,EAAyC;AACvCwB,QAAAA,GADuC;AAEvCwB,QAAAA,OAFuC;AAGvCM,QAAAA,KAAK,EAAEN,OAHgC;AAIvC,WAAGZ,cAJoC;AAKvC,WAAGkC;AALoC,OAAzC;;AAQA,aAAO;AACLlC,QAAAA,cAAc,EAAEkC;AADX,OAAP;AAGD;;AAEDD,IAAAA,IAAI,CAACzC,KAAL,GAAa;AACXE,MAAAA,IAAI,EAAE,CAAE,KAAIA,IAAK,GAAX,CADK;AAEXC,MAAAA,EAAE,EAAEH;AAFO,KAAb;;AAKA,aAASA,KAAT,CAAe;AACbQ,MAAAA;AADa,KAAf,EAEG;AACD,YAAMkC,iBAAiB,GAAG;AACxB,SAACF,gBAAD,GAAoB;AADI,OAA1B;;AAIA3F,MAAAA,IAAI,CAACmE,SAAL,CAAemB,KAAf,CAAqB/D,cAAc,EAAnC,EAAuC;AACrCwB,QAAAA,GADqC;AAErCwB,QAAAA,OAFqC;AAGrCM,QAAAA,KAAK,EAAEN,OAH8B;AAIrC,WAAGZ,cAJkC;AAKrC,WAAGkC;AALkC,OAAvC;;AAQA,aAAO;AACLlC,QAAAA,cAAc,EAAEkC;AADX,OAAP;AAGD;;AAED,WAAO;AACL,OAAE,IAAGxC,IAAK,GAAV,GAAeuC,IADV;AAEL,OAAE,KAAIvC,IAAK,GAAX,GAAgBF;AAFX,KAAP;AAID;AACF;AACD;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\n// TODO: wrap in asyncWrapper\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n  // This is why most of the utilities are within the type function itself. If\n  // they weren't, then we'd have to pass the \"currentElement\" function to them\n  // as an argument, which would be fine, but make sure that you pass the function\n  // and not just the element if the active element could change while the function\n  // is being run (for example, functions that are and/or fire events).\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument);\n\n  const currentValue = () => {\n    const activeElement = currentElement();\n    const value = activeElement.value;\n\n    if (typeof value === 'undefined') {\n      throw new TypeError(`the current element is of type ${activeElement.tagName} and doesn't have a valid value`);\n    }\n\n    return value;\n  };\n\n  const setSelectionRange = ({\n    newValue,\n    newSelectionStart\n  }) => {\n    // if we *can* change the selection start, then we will if the new value\n    // is the same as the current value (so it wasn't programatically changed\n    // when the fireEvent.input was triggered).\n    // The reason we have to do this at all is because it actually *is*\n    // programmatically changed by fireEvent.input, so we have to simulate the\n    // browser's default behavior\n    const value = currentValue();\n\n    if (value === newValue) {\n      (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n    } else {\n      // If the currentValue is different than the expected newValue and we *can*\n      // change the selection range, than we should set it to the length of the\n      // currentValue to ensure that the browser behavior is mimicked.\n      (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n    }\n  }; // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  if (currentElement().selectionStart === 0 && currentElement().selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : currentValue().length, initialSelectionEnd != null ? initialSelectionEnd : currentValue().length);\n  }\n\n  const eventCallbackMap = getEventCallbackMap({\n    currentElement,\n    currentValue,\n    fireInputEventIfNeeded,\n    setSelectionRange\n  });\n\n  const eventCallbacks = function () {\n    const callbacks = [];\n    const modifierClosers = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const eventKey = Object.keys(eventCallbackMap).find(key => remainingString.startsWith(key));\n\n      if (eventKey) {\n        const modifierCallback = eventCallbackMap[eventKey];\n        callbacks.push(modifierCallback); // if this modifier has an associated \"close\" callback and the developer\n        // doesn't close it themselves, then we close it for them automatically\n        // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n        if (!skipAutoClose && modifierCallback.close && !remainingString.includes(modifierCallback.close.name)) {\n          modifierClosers.push(modifierCallback.close.fn);\n        }\n\n        remainingString = remainingString.slice(eventKey.length);\n      } else {\n        const character = remainingString[0];\n        callbacks.push((...args) => typeCharacter(character, ...args));\n        remainingString = remainingString.slice(1);\n      }\n    }\n\n    return [...callbacks, ...modifierClosers];\n  }();\n\n  await async function (callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n      }\n    }\n  }(eventCallbacks);\n\n  function fireInputEventIfNeeded({\n    newValue,\n    newSelectionStart,\n    eventOverrides\n  }) {\n    const prevValue = currentValue();\n\n    if (!currentElement().readOnly && newValue !== prevValue) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n\n      setSelectionRange({\n        newValue,\n        newSelectionStart\n      });\n    }\n\n    return {\n      prevValue\n    };\n  }\n\n  function typeCharacter(char, {\n    prevWasMinus = false,\n    prevWasPeriod = false,\n    prevValue = '',\n    eventOverrides\n  }) {\n    const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n    const keyCode = char.charCodeAt(0);\n    let nextPrevWasMinus, nextPrevWasPeriod;\n\n    const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyDownDefaultNotPrevented) {\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n        key,\n        keyCode,\n        charCode: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        let newEntry = char;\n\n        if (prevWasMinus) {\n          newEntry = `-${char}`;\n        } else if (prevWasPeriod) {\n          newEntry = `${prevValue}.${char}`;\n        }\n\n        const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement(), currentValue()),\n          eventOverrides: {\n            data: key,\n            inputType: 'insertText',\n            ...eventOverrides\n          }\n        });\n        prevValue = inputEvent.prevValue; // typing \"-\" into a number input will not actually update the value\n        // so for the next character we type, the value should be set to\n        // `-${newEntry}`\n        // we also preserve the prevWasMinus when the value is unchanged due\n        // to typing an invalid character (typing \"-a3\" results in \"-3\")\n        // same applies for the decimal character.\n\n        if (currentElement().type === 'number') {\n          const newValue = currentValue();\n\n          if (newValue === prevValue && newEntry !== '-') {\n            nextPrevWasMinus = prevWasMinus;\n          } else {\n            nextPrevWasMinus = newEntry === '-';\n          }\n\n          if (newValue === prevValue && newEntry !== '.') {\n            nextPrevWasPeriod = prevWasPeriod;\n          } else {\n            nextPrevWasPeriod = newEntry === '.';\n          }\n        }\n      }\n    }\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides\n    });\n\n    return {\n      prevWasMinus: nextPrevWasMinus,\n      prevWasPeriod: nextPrevWasPeriod,\n      prevValue\n    };\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element, value) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element, value) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = element;\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction getEventCallbackMap({\n  currentElement,\n  currentValue,\n  fireInputEventIfNeeded,\n  setSelectionRange\n}) {\n  return { ...modifier({\n      name: 'shift',\n      key: 'Shift',\n      keyCode: 16,\n      modifierProperty: 'shiftKey'\n    }),\n    ...modifier({\n      name: 'ctrl',\n      key: 'Control',\n      keyCode: 17,\n      modifierProperty: 'ctrlKey'\n    }),\n    ...modifier({\n      name: 'alt',\n      key: 'Alt',\n      keyCode: 18,\n      modifierProperty: 'altKey'\n    }),\n    ...modifier({\n      name: 'meta',\n      key: 'Meta',\n      keyCode: 93,\n      modifierProperty: 'metaKey'\n    }),\n    '{enter}': ({\n      eventOverrides\n    }) => {\n      const key = 'Enter';\n      const keyCode = 13;\n\n      const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyDownDefaultNotPrevented) {\n        _dom.fireEvent.keyPress(currentElement(), {\n          key,\n          keyCode,\n          charCode: keyCode,\n          ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'BUTTON') {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement(), currentValue());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{esc}': ({\n      eventOverrides\n    }) => {\n      const key = 'Escape';\n      const keyCode = 27;\n\n      _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{del}': ({\n      eventOverrides\n    }) => {\n      const key = 'Delete';\n      const keyCode = 46;\n\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement(), currentValue()),\n          eventOverrides: {\n            inputType: 'deleteContentForward',\n            ...eventOverrides\n          }\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    '{backspace}': ({\n      eventOverrides\n    }) => {\n      const key = 'Backspace';\n      const keyCode = 8;\n\n      const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n\n      if (keyPressDefaultNotPrevented) {\n        fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement(), currentValue()),\n          eventOverrides: {\n            inputType: 'deleteContentBackward',\n            ...eventOverrides\n          }\n        });\n      }\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides\n      });\n    },\n    // the user can actually select in several different ways\n    // we're not going to choose, so we'll *only* set the selection range\n    '{selectall}': () => {\n      currentElement().setSelectionRange(0, currentValue().length);\n    }\n  };\n\n  function modifier({\n    name,\n    key,\n    keyCode,\n    modifierProperty\n  }) {\n    function open({\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: true\n      };\n\n      _dom.fireEvent.keyDown(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n\n    open.close = {\n      name: [`{/${name}}`],\n      fn: close\n    };\n\n    function close({\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: false\n      };\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n\n    return {\n      [`{${name}}`]: open,\n      [`{/${name}}`]: close\n    };\n  }\n}\n/*\neslint\n  no-loop-func: \"off\",\n  max-lines-per-function: \"off\",\n*/"]},"metadata":{},"sourceType":"script"}